
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% abnTeX2: Modelo de Relatório Técnico/Acadêmico em conformidade com 
% ABNT NBR 10719:2011 Informação e documentação - Relatório técnico e/ou
% científico - Apresentação
% ------------------------------------------------------------------------ 
% ------------------------------------------------------------------------

\documentclass[
	% -- opções da classe memoir --
	12pt,				% tamanho da fonte
	openright,			% capítulos começam em pág ímpar (insere página vazia caso preciso)
	oneside,			% para impressão em verso e anverso. Oposto a oneside
	a4paper,			% tamanho do papel. 
	% -- opções da classe abntex2 --
	%chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	french,				% idioma adicional para hifenização
	spanish,			% idioma adicional para hifenização
	brazil,				% o último idioma é o principal do documento
	]{abntex2}


% ---
% PACOTES
% ---

% ---
% Pacotes fundamentais 
% ---
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{microtype} 			% para melhorias de justificação
\usepackage{amssymb}
\usepackage[boxruled, linesnumbered, portuguese]{algorithm2e}
\usepackage{alltt}
% ---

% ---
% Pacotes adicionais, usados no anexo do modelo de folha de identificação
% ---
\usepackage{multicol}
\usepackage{multirow}
% ---
	
% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}				% para geração de dummy text
% ---

% ---
% Pacotes de citações
% ---
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}	% Citações padrão ABNT
\usepackage{listings}
% --- 
% CONFIGURAÇÕES DE PACOTES
% --- 

% ---
% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
	\ifcase #1 %
		Nenhuma citação no texto.%
	\or
		Citado na página #2.%
	\else
		Citado #1 vezes nas páginas #2.%
	\fi}%
% ---

% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\titulo{Método Simplex \\ Fases I e II}
\autor{Florence Alyssa Sakuma Shibata \and Shayenne da Luz Moura}
\local{São Paulo}
\data{2015}
\instituicao{%
  Universidade de São Paulo -- USP
  \par
  Instituto de Matemática e Estatística
  \par
  Bacharelado em Ciência da Computação}
\tipotrabalho{Relatório técnico}
% O preambulo deve conter o tipo do trabalho, o objetivo, 
% o nome da instituição e a área de concentração 
\preambulo{Relatório dos resultados dos testes do segundo trabalho.}
% ---

% ---
% Configurações de aparência do PDF final

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

% informações do PDF
\makeatletter
\hypersetup{
     	%pagebackref=true,
		pdftitle={\@title}, 
		pdfauthor={\@author},
    	pdfsubject={\imprimirpreambulo},
	    pdfcreator={LaTeX with abnTeX2},
		pdfkeywords={abnt}{latex}{abntex}{abntex2}{relatório técnico}, 
		colorlinks=true,       		% false: boxed links; true: colored links
    	linkcolor=blue,          	% color of internal links
    	citecolor=blue,        		% color of links to bibliography
    	filecolor=magenta,      		% color of file links
		urlcolor=blue,
		bookmarksdepth=4
}
\makeatother
% --- 

% --- 
% Espaçamentos entre linhas e parágrafos 
% --- 

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

% ---
%% compila o indice
%% ---
\makeindex
% ---

% ----
% Início do documento
% ----
\begin{document}

% Retira espaço extra obsoleto entre as frases.
\frenchspacing 

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
\pretextual

% ---
% Capa
% ---
\imprimircapa
% ---

% ---
% Folha de rosto
% (o * indica que haverá a ficha bibliográfica)
% ---
%\imprimirfolhaderosto*
% ---


% ---
% RESUMO
% ---

% resumo na língua vernácula (obrigatório)
%\setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo
%\begin{resumo}
%Este relatório trata do desenvolvimento do algoritmo simplex, com implementação revisada, que encontra uma solução ótima de problemas que possuam pelo menos uma solução viável básica e nenhuma delas seja degenerada, recebendo em sua inicialização uma solução viável básica. Por fim, todos os resultados foram condizentes com o esperado.
%
% \noindent
% \textbf{Palavras-chaves}: solução ótima. simplex revisado. problema programação linear.
%\end{resumo}
% ---

%% ---
%% inserir lista de ilustrações
%% ---
%\pdfbookmark[0]{\listfigurename}{lof}
%\listoffigures*
%\cleardoublepage
%% ---
%
%% ---
%% inserir lista de tabelas
%% ---
%\pdfbookmark[0]{\listtablename}{lot}
%\listoftables*
%\cleardoublepage
%% ---
%
%% ---
%% inserir lista de abreviaturas e siglas
%% ---
%\begin{siglas}
%  \item[ABNT] Associação Brasileira de Normas Técnicas
%  \item[abnTeX] ABsurdas Normas para TeX
%\end{siglas}
%% ---
%
%% ---
%% inserir lista de símbolos
%% ---
%\begin{simbolos}
%  \item[$ \Gamma $] Letra grega Gama
%  \item[$ \Lambda $] Lambda
%  \item[$ \zeta $] Letra grega minúscula zeta
%  \item[$ \in $] Pertence
%\end{simbolos}
%% ---
%
%% ---
% inserir o sumario
% ---
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
%% ---
%
%
%% ----------------------------------------------------------
%% ELEMENTOS TEXTUAIS
%% ----------------------------------------------------------
%\textual

% ----------------------------------------------------------
% Introdução
% ----------------------------------------------------------
\chapter*[Introdução]{Introdução}
\addcontentsline{toc}{chapter}{Introdução}

O método simplex é baseado em encontrar uma solução ótima para um problema de programação linear e realiza esta busca movendo-se de uma solução viável básica para outra, percorrendo os lados do poliedro que define a região viável, sempre numa direção onde o custo se reduz. Quando uma solução viável básica é alcançada e nenhuma das direções viáveis reduzem o custo temos então a solução ótima, e o algoritmo termina. 

O método simplex necessita receber uma solução viável básica inicial não degenerada. Para isso, são introduzidas variáveis de folga, não negativas, no problema original, criando assim um problema auxiliar no qual se conhece uma solução viável básica inicial. Ao resolvê-lo, é possível decidir se o problema original é viável, e se for, também encontra uma solução viável básica inicial para ele. 




% ----------------------------------------------------------
% PARTE - preparação da pesquisa
% ----------------------------------------------------------
%\section{Descriįão do método} 
%%Dar enfase ao fato de que as todas as soluįões viáveis básicas são 
%%não degeneradas e o problema possui pelo menos uma soluįão básica
%\section{Desenvolvimento do algoritmo}
%
%\section{Resumo do funcionamento}
%Dadas uma matriz A \in mxn, uma svb x \in n, b \in m, o vetor de custos c \in n.
%Passos do algoritmo
%\begin{itemize}
%\item[1] Gera a matriz básica B associada a x.
%\item[2] Calcula o vetor de custos reduzidos para toda variável não
% básica. Se nenhuma componente é negativa, então a svb atual é
% ótima, acabou. 
%\item[3]Caso contrário, armazena o índice da variável cujo custo reduzido foi menor.
%Calcule u = B^(-1)A_j. Se nenhum componente de u é positivo,
%temos que o custo ótimo é - \infinity, acabou;
%\item[4]Caso contrário, tomamos \theta * = min{x_(B(i))/u_i}
%Seja l o indice onde o minimo foi encontrado. Forma uma nova
%base substituindo A_(B(l)) por A_j. Se y é a nova svb, os valores
%das novas variáveis básicas são y_j = \theta *, y_B(i) - theta*u_i, i!=l. 
%\end{itemize}
%
%\section{Complexidade do algoritmo}
%% Mostrar os passos e quanto custa por cada um deles
%
%% Utilizou-se a implementaįão de LU calculando o produto
%% de matrizes triangulares superiores e inferiores pois
%% o Octave utiliza a inversa da matriz para calcular x = b /A
%
%O algoritmo desenvolvido possui características ingęnuas em relaįão a sua 
%complexidade. Poderia ser mais rápido caso houvesse apenas a atualizaįão do
%LU em cada iteraįão, ao invés de seu cálculo novamente.
%O comportamento do algoritmo seria o mesmo, uma vez que este não depende da
%forma que se calculam os valores.
%
%\section{Testes}
%% Reforįar as hipóteses utilizadas em cada caso.
%\subsection{Soluįão ótima dada}
%% Como todas as componentes do vetor de custos reduzidos são não negativas temos
%% que a soluįão em que nos encontramos é ótima, pela suposiįão de que não existe
%% svb degenerada
%\subsection{Custo ótimo ilimitado}
%
%\subsection{Soluįão ótima diferente}
%
%\section{Resultados}
% ----------------------------------------------------------
% Capitulo com exemplos de comandos inseridos de arquivo externo 
% ----------------------------------------------------------
\chapter{Descrição do algoritmo}
\section{Fase I}
O método simplex fase I utilizado como base para o desenvolvimento do algoritmo está descrito em
  \citeonline[pág. 116-117]{bertsimas1997introduction}. 
  
Dadas uma matriz $A \in \Re ^{m \times n}$, $b \in \Re ^m$, o vetor de custos $c \in\Re ^n$, o algoritmo realiza os seguintes passos:

\begin{itemize}
\item[1] Multiplica algumas restrições por -1, mudando o problema para que $b \geq 0$.

\item[2] Introduz variáveis artificiais $y_1, \ldots, y_m$, se necessário, e aplica o método simplex ao problema auxiliar com função de custo $ \Sigma_{i=1}^{m}y_i $.

\item[3] Se o custo ótimo do problema auxiliar é positivo, o problema original é inviável e o algoritmo termina.

\item[4] Se o custo ótimo é 0, uma solução viável para o problema original foi encontrada. Se nenhuma variável artificial está na base final, as variáveis artificiais são eliminadas, e uma base viável para o problema foi encontrada.

\item[5] Se a $l$-ésima variável básica é artificial, examinamos a $l$-ésima entrada das colunas de $B{-1}A_j$, $j = 1, \ldots, n$. Se todas as entradas são zero, a $l$-ésima linha representa uma restrição redundante e é eliminada. Caso contrário, se a $l$-ésima entrada da $j$-ésima coluna é diferente de zero, aplica a mudança de base (com esta entrando e servindo de elemento pivô): a $l$-ésima variável básica sai e $x_j$ entra na base. Repete essa operação até que todas as variáveis artificiais sejam tiradas da base. 
\end{itemize}

\section{Fase II}
O método simplex fase II utilizado como base para o desenvolvimento do algoritmo está descrito em
  \citeonline[pág. 90-91]{bertsimas1997introduction}. 
  
  Dadas uma matriz $A \in \Re ^{m \times n}$, uma solução viável básica $x \in \Re ^n$, $b \in \Re ^m$, o vetor de custos $c \in\Re ^n$, o algoritmo realiza os seguintes passos:
  
\begin{itemize}
\item[1] Gera a matriz básica $B$ associada a $x$.
\item[2] Calcula o vetor de custos reduzidos para toda variável não
 básica. Se nenhuma componente é negativa, então a solução viável básica atual é
 ótima, acabou. 
\item[3]Caso contrário, armazena o índice da variável cujo custo reduzido foi menor.
Calcula $u = B^{-1}A_j$. Se nenhum componente de $u$ é positivo,
então o custo ótimo é $- \infty$, acabou;
\item[4]Caso contrário, toma $\theta ^* = min_{(i = 1,\ldots,m|u_i > 0)} \{\frac{x_{B(i)}}{u_i}\} $.
Seja $l$ o índice onde o mínimo foi encontrado. Forma uma nova
base substituindo $A_{B(l)}$ por $A_j$. Sendo $y$ é a nova solução viável básica, os valores
das novas variáveis básicas são $y_j = \theta ^*$, $y_{B(i)} - \theta ^* u_i$, $i\neq l$. Volta ao passo 1.
\end{itemize}



\chapter{Funcionamento do algoritmo}

A seguir está a descrição do funcionamento do algoritmo quando o problema de
programação linear dado é inviável, possui pelo menos uma solução ótima e quando o custo 
ótimo é ilimitado. 

Também é apresentado um exemplo de problema no qual o algoritmo falha por tentar o cálculo da fase 2 com uma solução viável básica degenerada, encontrada pela fase 1. Por fim, um problema que mostra o funcionamento do algoritmo ao encontrar soluções degeneradas.


\section{Problema inviável}
O objetivo da fase 1 é decidir se existe ou não solução viável, e se existir, devolve a mesma para a fase 2.

O problema a seguir não possui região viável. Ao calcular o problema auxiliar, o algoritmo encontra uma solução ótima maior que zero. Assim, temos que o problema de programação linear original é inviável.

\begin{verbatim}
[ind, x, d] = simplex(A, b, c, m, n)
#====================================
          Simplex Fase 1
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
5:  12.000000
6:  20.000000

Valor funcao objetivo: 32.000000

Custos reduzidos:
1: -2.000000

Entra na base: 1

Direcao
5: 1.000000
6: 1.000000

Theta*: 12.000000

Sai da base: 5

#====================================
           Iteracao: 1
#====================================
Variaveis basicas:
1:  12.000000
6:  8.000000

Valor funcao objetivo: 8.000000

Custos reduzidos:
5: 2.000000
2: 0.000000
3: 1.000000
4: 1.000000
O problema é inviável 
\end{verbatim}


\section{Problema com solução ótima}
Fornecendo a seguinte entrada, temos abaixo descrito o resultado do algoritmo:

\begin{verbatim}
 A = [1 2 3 0; -1 2 6 0; 0 4 9 0; 0 0 3 1]
 b = [3;2;5;1]
 c = [1;1;1;0]
 m = 4
 n = 4
\end{verbatim}

Na fase 1, O algoritmo irá acrescentar as variáveis artificiais e resolver o problema auxiliar, afim de decidir se o problema é inviável ou encontrar uma solução viável básica para o problema original.

\begin{verbatim}
> [ind, x, d] = simplex(A, b, c, m, n)
#====================================
          Simplex Fase 1
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
5:  3.000000
6:  2.000000
7:  5.000000
8:  1.000000

Valor funcao objetivo: 11.000000

Custos reduzidos:
1: 0.000000
2: -8.000000

Entra na base: 2

Direcao
5: 2.000000
6: 2.000000
7: 4.000000
8: 0.000000

Theta*: 1.000000

Sai da base: 6

#====================================
           Iteracao: 1
#====================================
Variaveis basicas:
5:  1.000000
2:  1.000000
7:  1.000000
8:  1.000000

Valor funcao objetivo: 3.000000

Custos reduzidos:
1: -4.000000

Entra na base: 1

Direcao
5: 2.000000
2: -0.500000
7: 2.000000
8: 0.000000

Theta*: 0.500000

Sai da base: 5

#====================================
           Iteracao: 2
#====================================
Variaveis basicas:
1:  0.500000
2:  1.250000
7:  0.000000
8:  1.000000

Valor funcao objetivo: 1.000000

Custos reduzidos:
5: 2.000000
6: 2.000000
3: -3.000000

Entra na base: 3

Direcao
1: -1.500000
2: 2.250000
7: 0.000000
8: 3.000000

Theta*: 0.333333

Sai da base: 8

#====================================
           Iteracao: 3
#====================================
Variaveis basicas:
1:  1.000000
2:  0.500000
7:  0.000000
3:  0.333333

Valor funcao objetivo: 0.000000

Custos reduzidos:
5: 2.000000
6: 2.000000
8: 1.000000
4: 0.000000
\end{verbatim}
Nesse momento, todos os custos reduzidos são não negativos, logo foi encontrada uma solução ótima para o problema auxiliar.

O algoritmo verifica que o custo ótimo desta solução é igual a zero. Isso quer dizer que o problema original é viável e na solução encontrada, podemos encontrar uma solução viável báśica para o original.

Como ainda sobraram variáveis artificiais na base da solução temos que as restrições associadas a essas váriáveis são redundantes no problema original. Logo, são removidas e assim é possível resolver o problema original com a solução encontrada.

A partir de agora, inicia-se a fase 2.

\begin{verbatim}
#====================================
          Simplex Fase 2
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
1:  1.000000
2:  0.500000
3:  0.333333

Valor funcao objetivo: 1.833333

Custos reduzidos:
4: -0.083333

Entra na base: 4

Direcao
1: 0.500000
2: -0.750000
3: 0.333333

Theta*: 1.000000

Sai da base: 3

#====================================
           Iteracao: 1
#====================================
Variaveis basicas:
1:  0.500000
2:  1.250000
4:  1.000000

Valor funcao objetivo: 1.750000

Custos reduzidos:
3: 0.250000

Solucao e otima 
ind = 0
x =

   0.50000
   1.25000
   0.00000
   1.00000

d = 0
\end{verbatim}
A solução devolvida em x é a solução ótima para o problema original.
%--------------------------------------------------------------------------------------------
%Ao aplicar o algoritmo com os dados descritos a seguir, pode-se verificar seu funcionamento.
%\begin{verbatim}
%> A = [1 0 1 0 0; 0 1 0 1 0; 3 2 0 0 1];
%> x = [0;0;4;6;18];
%> b = [4;16;18];
%> m = 3;
%> n = 5;
%> c = [3;5;0;0;0];
%
%> [ind, v] = simplex(A, b, c, m, n, x);
%#====================================
%           Iteracao: 0
%#====================================
%
%Variaveis basicas:
%3:  4.000000
%4:  6.000000
%5:  18.000000
%
%Valor funcao objetivo: 0.000000
%\end{verbatim}
%
%O algoritmo calcula quais são as váriáveis básicas a partir da solução x dada e o custo associado a essa solução c$^T$x.
%
%\begin{verbatim}
%Custos reduzidos:
%1: 3.000000
%2: 5.000000
%\end{verbatim}
%
%Como o vetor de custos reduzidos das variáveis não básicas é positivo não existe direção viável que reduza o custo. Logo, o custo ótimo é alcançado em x. Assim, x é solução ótima.
%
%\begin{verbatim}
%Solucao otima com custo 0.000000:
%1  0.000000
%2  0.000000
%3  4.000000
%4  6.000000
%5  18.000000
%\end{verbatim}
%O algoritmo então devolve o valor da solução ótima que é igual a solução viável básica x dada.
%
%
%O problema de programação linear descrito a seguir também possui uma solução viável básica ótima que é encontrada após algumas iterações.
%\begin{verbatim}
%> A = [1 2 3 0 1 0 0 0 ;-1 2 6 0 0 1 0 0; 0 4 9 0 0 0 1 0; 0 0 3 4 0 0 0 1];
%> c = [0;0;0;0;1;1;1;1];
%> x = [0; 0; 0; 0; 3; 2; 5; 1];
%> m = 4;
%> n = 8;
%
%> [ind, v] = simplex(A, b, c, m, n, x);
%#====================================
%           Iteracao: 0
%#====================================
%Variaveis basicas:
%5:  3.000000
%6:  2.000000
%7:  5.000000
%8:  1.000000
%
%Valor funcao objetivo: 11.000000
%
%Custos reduzidos:
%1: 0.000000
%2: -8.000000
%3: -21.000000
%4: -4.000000
%\end{verbatim}
%
%O algoritmo calcula quais são as váriáveis básicas da solução viável básica x, o custo associado a ela e os custos reduzidos das variáveis não básicas. Quando encontra um valor negativo sabe-se que existe uma solução viável básica, diferente de x, cujo custo associado é menor. A direção de menor custo associado é escolhida, neste caso, a variável 3.
%
%\begin{verbatim}
%Entra na base: 3
%
%Direcao
%5: 3.000000
%6: 6.000000
%7: 9.000000
%8: 3.000000
%
%Theta*: 0.333333
%
%Sai da base: 6
%\end{verbatim}
%
%É calculada a direção viável que reduz o custo, além do $\theta$ máximo que se pode andar para estar sobre uma nova solução viável básica. Como nessa direção o valor da função objetivo é menor que $-\infty$ existe uma solução viável básica associada. A variável encontrada que possuir menor custo reduzido entra na base e apenas uma das variáveis básicas torna-se zero, pois as soluções são todas não degeneradas. Neste caso, aquela que torna o $\theta$ máximo, a variável 6.
%Uma nova iteração se inicia com a solução viável básica associada a nova base.
%
%\begin{verbatim}
%#====================================
%           Iteracao: 1
%#====================================
%Variaveis basicas:
%5:  2.000000
%3:  0.333333
%7:  2.000000
%8:  0.000000
%
%Valor funcao objetivo: 4.000000
%
%Custos reduzidos:
%1: -3.500000
%2: -1.000000
%6: 3.500000
%4: -4.000000
%
%Entra na base: 4
%
%Direcao
%5: 0.000000
%3: 0.000000
%7: 0.000000
%8: 4.000000
%
%Theta*: 0.000000
%
%Sai da base: 8
%\end{verbatim}
%
%Esta iteração realiza os mesmos passos da iteração anterior, encontrando a direção de menor custo reduzido, colocando na base a variável 4. O $\theta$ máximo que se pode andar para estar sobre uma nova solução viável básica é menor que $-\infty$ e a variável 8 sai da base.
%Uma nova iteração se inicia com a solução viável básica associada a nova base.
%
%\begin{verbatim}
%#====================================
%           Iteracao: 2
%#====================================
%Variaveis basicas:
%5:  2.000000
%3:  0.333333
%7:  2.000000
%4:  0.000000
%
%Valor funcao objetivo: 4.000000
%
%Custos reduzidos:
%1: -3.000000
%2: -2.000000
%6: 3.000000
%8: 1.000000
%
%Entra na base: 1
%
%Direcao
%5: 1.500000
%3: -0.166667
%7: 1.500000
%4: 0.125000
%
%Theta*: 0.000000
%
%Sai da base: 4
%\end{verbatim}
%
%Idêntica a iteração anterior, encontra a direção de menor custo reduzido, colocando na base a variável 1. O $\theta$ máximo que se pode andar para estar sobre uma nova solução viável básica é menor que $-\infty$ e a variável 4 sai da base.
%Uma nova iteração se inicia com a solução viável básica associada a nova base.
%
%\begin{verbatim}
%#====================================
%           Iteracao: 3
%#====================================
%Variaveis basicas:
%5:  2.000000
%3:  0.333333
%7:  2.000000
%1:  0.000000
%
%Valor funcao objetivo: 4.000000
%
%Custos reduzidos:
%4: 24.000000
%2: -8.000000
%6: 0.000000
%8: 7.000000
%
%Entra na base: 2
%
%Direcao
%5: 4.000000
%3: 0.000000
%7: 4.000000
%1: -2.000000
%
%Theta*: 0.500000
%
%Sai da base: 5
%\end{verbatim}
%
%Esta iteração realiza os mesmos passos da iteração anterior, encontrando a direção de menor custo reduzido, colocando na base a variável 2. O $\theta$ máximo que se pode andar para estar sobre uma nova solução viável básica é menor que $-\infty$ e a variável 5 sai da base.
%Uma nova iteração se inicia com a solução viável básica associada a nova base.
%
%\begin{verbatim}
%#====================================
%           Iteracao: 4
%#====================================
%Variaveis basicas:
%2:  0.500000
%3:  0.333333
%7:  0.000000
%1:  1.000000
%
%Valor funcao objetivo: 0.000000
%
%Custos reduzidos:
%4: 0.000000
%5: 2.000000
%6: 2.000000
%8: 1.000000
%
%Solucao otima com custo 0.000000:
%1  1.000000
%2  0.500000
%3  0.333333
%4  0.000000
%5  0.000000
%6  0.000000
%7  0.000000
%8  0.000000
%\end{verbatim}
%
%Esta possui o vetor de custos reduzidos positivo. Logo não existe direção viável que reduza o custo. O algoritmo devolve a solução viável básica em que está como solução ótima, pois esta possui menor custo associado.  
%  
  
\section{Problema com custo ótimo ilimitado}
Como exemplo do funcionamento do algoritmo para um problema de programação linear que contém solução ilimitada segue os dados de entrada.

\begin{verbatim}
> A = [1 -1 1 0; 2 -1 0 1];
> b = [10; 40]
 c = [-2; -1; 0; 0];
 m = 2;
 n = 4;
\end{verbatim}

A execução do algoritmo devolve as iterações a seguir. 

\begin{verbatim}
> [ind, x, d] = simplex(A, b, c, m, n)
#====================================
          Simplex Fase 1
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
5:  10.000000
6:  40.000000

Valor funcao objetivo: 50.000000

Custos reduzidos:
1: -3.000000

Entra na base: 1

Direcao
5: 1.000000
6: 2.000000

Theta*: 10.000000

Sai da base: 5

#====================================
           Iteracao: 1
#====================================
Variaveis basicas:
1:  10.000000
6:  20.000000

Valor funcao objetivo: 20.000000

Custos reduzidos:
5: 3.000000
2: -1.000000

Entra na base: 2

Direcao
1: -1.000000
6: 1.000000

Theta*: 20.000000

Sai da base: 6

#====================================
           Iteracao: 2
#====================================
Variaveis basicas:
1:  30.000000
2:  20.000000

Valor funcao objetivo: 0.000000

Custos reduzidos:
5: 1.000000
6: 1.000000
3: 0.000000
4: 0.000000
#====================================
          Simplex Fase 2
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
1:  30.000000
2:  20.000000

Valor funcao objetivo: -80.000000

Custos reduzidos:
3: -4.000000

O valor da funcao objetivo vai para -Inf

Solucao possui custo -Inf
ind = -1
x = 0
d =

  -1
  -2
   0
   0
\end{verbatim}
Em d, é devolvida a direção viável para a qual o custo é ilimitado.
%-----------------------------------------------------------------------------------------
%
%\begin{verbatim}
%> [ind, v ]= simplex(A, b, c, m, n, x);
%#====================================
%           Iteracao: 0
%#====================================
%Variaveis basicas:
%3:  10.000000
%4:  40.000000
%
%Valor funcao objetivo: 0.000000
%
%Custos reduzidos:
%1: -2.000000
%2: -1.000000
%
%Entra na base: 1
%
%Direcao
%3: 1.000000
%4: 2.000000
%
%Theta*: 10.000000
%
%Sai da base: 3
%\end{verbatim}
%
%Esta iteração encontra a direção de menor custo reduzido, neste caso, colocando na base a variável 1. O $\theta$ máximo que se pode andar para estar sobre uma nova solução viável básica é menor que $-\infty$ e a variável 3 sai da base.
%Uma nova iteração se inicia com a solução viável básica associada a nova base.
%
%\begin{verbatim}
%#====================================
%           Iteracao: 1
%#====================================
%Variaveis basicas:
%1:  10.000000
%4:  20.000000
%
%Valor funcao objetivo: -20.000000
%
%Custos reduzidos:
%3: 2.000000
%2: -3.000000
%
%Entra na base: 2
%
%Direcao
%1: -1.000000
%4: 1.000000
%
%Theta*: 20.000000
%
%Sai da base: 4
%\end{verbatim}
%
%Assim como a iteração anterior, encontra a direção de menor custo reduzido, colocando na base a variável 2. O $\theta$ máximo que se pode andar para estar sobre uma nova solução viável básica é menor que $-\infty$ e a variável 4 sai da base.
%Uma nova iteração se inicia com a solução viável básica associada a nova base.
%
%\begin{verbatim}
%#====================================
%           Iteracao: 2
%#====================================
%Variaveis basicas:
%1:  30.000000
%2:  20.000000
%
%Valor funcao objetivo: -80.000000
%
%Custos reduzidos:
%3: -4.000000
%4: 3.000000
%\end{verbatim}
%
%Ao andar na direção da variável básica $j$ cujo custo reduzido é o menor negativo encontra-se o vetor $u = B^{-1}A_j$ com elementos não positivos, isso quer dizer que a direção encontrada leva a solução ilimitada, com custo ótimo $-\infty$.
%
%\begin{verbatim}
%O valor da funcao objetivo vai para -Inf
%
%Direcao
%1: -1.000000
%2: -2.000000
%0: 0.000000
%0: 0.000000
%%\end{verbatim}
%O algoritmo devolve então a direção viável que possui solução ilimitada.

\section{Solução inicial degenerada}
Caso a fase 1 encontre uma solução viável básica degenerada, o problema original não pode ser resolvido por meio do simplex, uma vez que é necessário fornecer uma solução viável básica não degenerada para prosseguir o método simplex na fase 2.

Abaixo está transcrito o resultado do funcionamento do algoritmo e do erro ocasionado ao tentar iniciar o simplex fase 2 com uma solução viável básica degenerada.

A seguinte entrada:
\begin{verbatim}
> A = [4 4 1 0 0 0; 2 0 0 1 0 0;-1 3 0 0 1 0;0 1 0 0 0 1]
> b = [28;10;9;4]
> c = [0;-1;0;0;0;0]
> m=4
> n=6
\end{verbatim}

Tem o seguinte resultado:
\begin{verbatim}
> [ind, x, d] = simplex(A, b, c, m, n)
#====================================
          Simplex Fase 1
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
7:  28.000000
8:  10.000000
9:  9.000000
10:  4.000000

Valor funcao objetivo: 51.000000

Custos reduzidos:
1: -5.000000

Entra na base: 1

Direcao
7: 4.000000
8: 2.000000
9: -1.000000
10: 0.000000

Theta*: 5.000000

Sai da base: 8

#====================================
           Iteracao: 1
#====================================
Variaveis basicas:
7:  8.000000
1:  5.000000
9:  14.000000
10:  4.000000

Valor funcao objetivo: 26.000000

Custos reduzidos:
8: 2.500000
2: -8.000000

Entra na base: 2

Direcao
7: 4.000000
1: 0.000000
9: 3.000000
10: 1.000000

Theta*: 2.000000

Sai da base: 7

#====================================
           Iteracao: 2
#====================================
Variaveis basicas:
2:  2.000000
1:  5.000000
9:  8.000000
10:  2.000000

Valor funcao objetivo: 10.000000

Custos reduzidos:
8: -1.500000

Entra na base: 8

Direcao
2: -0.500000
1: 0.500000
9: 2.000000
10: 0.500000

Theta*: 4.000000

Sai da base: 9

#====================================
           Iteracao: 3
#====================================
Variaveis basicas:
2:  4.000000
1:  3.000000
8:  4.000000
10:  0.000000

Valor funcao objetivo: 4.000000

Custos reduzidos:
9: 0.750000
7: 1.437500
3: 0.437500
4: -1.000000

Entra na base: 4

Direcao
2: 0.000000
1: 0.000000
8: 1.000000
10: 0.000000

Theta*: 4.000000

Sai da base: 8

#====================================
           Iteracao: 4
#====================================
Variaveis basicas:
2:  4.000000
1:  3.000000
4:  4.000000
10:  0.000000

Valor funcao objetivo: 0.000000

Custos reduzidos:
9: 1.250000
7: 1.062500
3: 0.062500
8: 1.000000
5: 0.250000
6: -1.000000

Entra na base: 6

Direcao
2: 0.000000
1: 0.000000
4: 0.000000
10: 1.000000

Theta*: 0.000000

Sai da base: 10

#====================================
           Iteracao: 5
#====================================
Variaveis basicas:
2:  4.000000
1:  3.000000
4:  4.000000
6:  0.000000

Valor funcao objetivo: 0.000000

Custos reduzidos:
9: 1.000000
7: 1.000000
3: 0.000000
8: 1.000000
5: 0.000000
10: 1.000000
#====================================
          Simplex Fase 2
error: inverse: argument must be a square matrix
error: called from:
error:   matrizB at line 172, column 8
error:   subsimplex at line 108, column 15
error:   simplex at line 85, column 13
\end{verbatim}
 
Sendo a solução viável básica fornecida degenerada, a matriz básica B associada a solução não é quadrada, não sendo possível calcular sua inversa. Era esperado que o programa devolvesse erro porque o código do simplex foi reaproveitado do EP2 e este supõe que a solução viável básica inicial é não degenerada.
 
\section{Problema com soluções viáveis básicas degeneradas} 
Caso o algoritmo encontre soluções viáveis básicas degeneradas ao percorrer as soluções básicas é possível encontrar a solução ótima sem que haja ciclagem.

A seguinte entrada exemplifica esta situação:
\begin{verbatim}
> A = [1/4 -8 -1 9 1 0 0 ; 1/2 -12 -1/2 3 0 1 0; 0 0 1 0 0 0 1]
> b = [1;2;3]
> c = [0;0;0;0;0;0;1]
> m = 3
> n = 7
\end{verbatim}

Sendo o resultado: 

\begin{verbatim}
> [ind, x, d] = simplex(A, b, c, m, n)
#====================================
          Simplex Fase 1
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
8:  1.000000
9:  2.000000
10:  3.000000

Valor funcao objetivo: 6.000000

Custos reduzidos:
1: -0.750000

Entra na base: 1

Direcao
8: 0.250000
9: 0.500000
10: 0.000000

Theta*: 4.000000

Sai da base: 8
\end{verbatim}

Na iteração 1, encontramos uma solução degenerada.

\begin{verbatim}
#====================================
           Iteracao: 1
#====================================
Variaveis basicas:
1:  4.000000
9:  0.000000
10:  3.000000

Valor funcao objetivo: 3.000000

Custos reduzidos:
8: 3.000000
2: -4.000000

Entra na base: 2

Direcao
1: -32.000000
9: 4.000000
10: 0.000000

Theta*: 0.000000

Sai da base: 9
\end{verbatim}

Na iteração 2, continuamos na mesma solução, porém as variáveis básicas são diferentes.

\begin{verbatim}
#====================================
           Iteracao: 2
#====================================
Variaveis basicas:
1:  4.000000
2:  0.000000
10:  3.000000

Valor funcao objetivo: 3.000000

Custos reduzidos:
8: 1.000000
9: 1.000000
3: -1.000000

Entra na base: 3

Direcao
1: 8.000000
2: 0.375000
10: 1.000000

Theta*: 0.000000

Sai da base: 2
\end{verbatim}

Na iteração 3, continuamos na mesma solução, porém as variáveis básicas são diferentes, não tornando a primeira formação da base.

\begin{verbatim}
#====================================
           Iteracao: 3
#====================================
Variaveis basicas:
1:  4.000000
3:  0.000000
10:  3.000000

Valor funcao objetivo: 3.000000

Custos reduzidos:
8: -0.333333

Entra na base: 8

Direcao
1: -1.333333
3: -1.333333
10: 1.333333

Theta*: 2.250000

Sai da base: 10
\end{verbatim}

Na iteração 4, saimos da solução degenerada.

\begin{verbatim}
#====================================
           Iteracao: 4
#====================================
Variaveis basicas:
1:  7.000000
3:  3.000000
8:  2.250000

Valor funcao objetivo: 2.250000

Custos reduzidos:
10: 0.250000
9: 1.500000
2: 2.000000
4: -7.500000

Entra na base: 4

Direcao
1: 6.000000
3: 0.000000
8: 7.500000

Theta*: 0.300000

Sai da base: 8

#====================================
           Iteracao: 5
#====================================
Variaveis basicas:
1:  5.200000
3:  3.000000
4:  0.300000

Valor funcao objetivo: 0.000000

Custos reduzidos:
10: 1.000000
9: 1.000000
2: 0.000000
8: 1.000000
5: 0.000000
6: 0.000000
7: 0.000000
#====================================
          Simplex Fase 2
#====================================
           Iteracao: 0
#====================================
Variaveis basicas:
1:  5.200000
3:  3.000000
4:  0.300000

Valor funcao objetivo: 0.000000

Custos reduzidos:
2: 0.000000
5: 0.000000
6: 0.000000
7: 1.000000

Solucao e otima 
ind = 0
x =

   5.20000
   0.00000
   3.00000
   0.30000
   0.00000
   0.00000
   0.00000

d = 0
\end{verbatim}

Mesmo tendo passado por soluções básicas degeneradas o algoritmo encontrou a solução ótima sem realizar ciclagem.
%\chapter{Testes}
%
%\include{testes}
% ----------------------------------------------------------
% Parte de revisãod e literatura
% ----------------------------------------------------------
%\chapter{Resultados}
%
%O desenvolvimento do algoritmo em linguagem Octave baseado no método simplex descrito em \citeonline{bertsimas1997introduction}.
%
%Além da análise do funcionamento do algoritmo, conforme descrito na seção anterior, que demonstrou a corretude do mesmo, desde que fossem garantidas as hipóteses sobre os parâmetros de inicialização.

% ---
% Capitulo de revisão de literatura
%% ---
%\include{resultados}
% ---
% Finaliza a parte no bookmark do PDF
% para que se inicie o bookmark na raiz
% e adiciona espaço de parte no Sumário
% ---
\phantompart

% ---
% Conclusão
% ---
\chapter*[Conclusão]{Conclusão}
\addcontentsline{toc}{chapter}{Conclusão}



O algoritmo simplex duas fases implementado é completo, no sentido de que abrange todas as possibilidades de resultado. Como a ciclagem é evitada, chegamos a um resultado diferente, de acordo com o problema.

Sendo o problema inviável, isto é detectado na fase 1. Sendo o problema viável mas as linhas de A sendo linearmente dependentes, isto é detectado e corrigido no fim da fase 1, pela eliminação de restrições de igualdade redundantes.

Sendo o custo ótimo é $-\infty$, isto é detectado enquanto se está na fase 2. Não se enquadrando em nenhum caso anterior, a fase 2 termina com a solução ótima do problema.
%
%O algoritmo desenvolvido apresentou desempenho conforme o esperado
%ao lidar com matrizes de posto completo, para as quais foram 
%calculadas as funções aproximadas e seus resíduos, e também de
%posto incompleto, onde apresentou solução esperada para o
%caso testado.
%
%
%Como se pode notar nos resultados, ao aumentar o grau do polinômio
%com o qual se buscava aproximar os dados, diminuiu-se o resíduo, isto é,
%a diferença entre os pontos e a função era menor. Com isso, obtinha-se 
%melhor estimação do que poderiam valer os pontos não descritos no sistema.
%Este fato também comprova a teoria de que quanto maior o grau do polinômio
%melhor é a aproximação com o método dos mínimos quadrados.
%
%
%Ao perturbar os valores de entrada, tanto dos coeficientes da matriz quanto
%dos valores do vetor, pode-se notar que a aproximação ainda continuava com 
%as mesmas características com o aumento do grau do polinômio aproximador.
%
%
%Alcançou-se o objetivo do algoritmo ao se confirmar os resultados teóricos
%em testes e experimentações, tanto quanto sua eficiência na resolução de
%sistemas lineares e minimização de resíduos de funções.

% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual

% ----------------------------------------------------------
% Referências bibliográficas
% ----------------------------------------------------------
\bibliography{references}

% ----------------------------------------------------------
% Glossário
% ----------------------------------------------------------
%
% Consulte o manual da classe abntex2 para orientações sobre o glossário.
%
%\glossary

% ----------------------------------------------------------
% Apêndices
% ----------------------------------------------------------

% ---
% Inicia os apêndices
% ---
%\begin{apendicesenv}
%
%% Imprime uma página indicando o início dos apêndices
%\partapendices
%
%% ----------------------------------------------------------
%\chapter{Quisque libero justo}
%% ----------------------------------------------------------
%
%\lipsum[50]
%
%% ----------------------------------------------------------
%\chapter{Nullam elementum urna vel imperdiet sodales elit ipsum pharetra ligula
%ac pretium ante justo a nulla curabitur tristique arcu eu metus}
%% ----------------------------------------------------------
%\lipsum[55-57]
%
% \end{apendicesenv}
%% ---
%
%
% ----------------------------------------------------------
% Anexos
% ----------------------------------------------------------

% ---
% Inicia os anexos
% ---
%\begin{anexosenv}
%%
%% Imprime uma página indicando o início dos anexos
%\partanexos
%
%%% ---
%\chapter{Código do algoritmo}
%
%\lstset{language=Octave,
%             basicstyle=\footnotesize,
%             numbers=left}
%\begin{lstlisting}
%SQUARE(REFERENCE,LENGTH,POT_INT,ATTRIB)
%\end{lstlisting}

%% ---
%\lipsum[30]
%
%% ---
%\chapter{Cras non urna sed feugiat cum sociis natoque penatibus et magnis dis
%parturient montes nascetur ridiculus mus}
%% ---
%
%\lipsum[31]
%
%% ---
%\chapter{Fusce facilisis lacinia dui}
%% ---
%
%\lipsum[32]
%%
%\end{anexosenv}
%%%

\end{document}
